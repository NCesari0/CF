# -*- coding: utf-8 -*-
"""Foam Cell Count.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QledyN_Oi2AWDGaZISrnvCbzzrl72Nvh

Cell Count Function
"""

import cv2
import numpy as np
from google.colab.patches import cv2_imshow
import cv2
def count_cells(image):
    # Read the image file as raw data
    with open(image, 'rb') as f:
        data = f.read()

    # Decode the image data and convert it to a NumPy array
    image2 = cv2.imdecode(np.frombuffer(data, np.uint8), cv2.IMREAD_COLOR)

    resized_image = cv2.resize(image2, (600, 600))

    # Convert the image to grayscale
    gray_image = cv2.cvtColor(resized_image, cv2.COLOR_BGR2GRAY)

    # Set the contrast factor
    alpha = 1.5

    # Set the brightness factor
    beta = 15

    # Increase the contrast and brightness of the image
    contrast_image = cv2.convertScaleAbs(gray_image, alpha=alpha, beta=beta)

    #Denoise
    denoised_image1 = cv2.fastNlMeansDenoising(contrast_image, None, 10, 7, 21)
    denoised_image = cv2.fastNlMeansDenoising(denoised_image1, None, 10, 7, 21)

    #kernel = np.array([[-1, -1, -1], [-1, 9, -1], [-1, -1, -1]])
    kernel = np.array([[-1, -1, -1], [-1, 9, -1], [-1, -1, -1]])/1.5
    #sharpened_image1 = cv2.filter2D(denoised_image, -1, kernel)
    sharpened_image = cv2.filter2D(denoised_image, -1, kernel)
    #inverted_image = cv2.bitwise_not(sharpened_image)
    kernel1 = np.ones((3, 3), np.uint8)

    # Apply erosion to reduce noise and make the objects in the image more distinct
    #erosion1 = cv2.erode(sharpened_image, kernel1, iterations=1)
    erosion = cv2.erode(sharpened_image, kernel1, iterations=1)

    #blurred = cv2.GaussianBlur(erosion, (5, 5), 10)

    # To make the cell count analysis less sensitive, you can try using a higher value for the block size in the adaptive thresholding step
    block_size = 19
    # To reduce the threshold, you can simply lower the value of the constant variable
    constant = 23

    best_block_size = 0
    best_constant = 0
    best_cell_count = 0


    for block_size in range(3, 21, 2):
        for constant in range(3, 21, 2):
            thresh = cv2.adaptiveThreshold(erosion, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, block_size,
                                           constant)
            kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3, 3))
            closing = cv2.morphologyEx(thresh, cv2.MORPH_CLOSE, kernel, iterations=1)
            opening = cv2.morphologyEx(closing, cv2.MORPH_OPEN, kernel, iterations=2)
            _, labels, _, _ = cv2.connectedComponentsWithStats(opening)
            cell_count = np.max(labels)
            if cell_count > best_cell_count:
                best_block_size = block_size
                best_constant = constant
                best_cell_count = cell_count

    # Use the best values to count the cells in the image
    # Apply Otsu's thresholding
    ret, thresh = cv2.threshold(erosion, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
    #thresh = cv2.adaptiveThreshold(erosion, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, best_block_size, best_constant)
    kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3, 3))
    closing = cv2.morphologyEx(thresh, cv2.MORPH_CLOSE, kernel, iterations=1)
    opening = cv2.morphologyEx(closing, cv2.MORPH_OPEN, kernel, iterations=1)#2
    _, labels, _, centroids = cv2.connectedComponentsWithStats(opening)
    cell_count = np.max(labels)

    # Display the labels on the image
    for label, centroid in zip(range(1, cell_count + 1), centroids):
        #text = "Cell {}".format(label,'red')
        x, y = centroid
        #cv2.putText(resized_image, text, (int(x), int(y)), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 200, 255), 2)
        cv2.circle(resized_image, (int(x), int(y)), 5, (0, 0, 255), -1)

    # Show Image Processing Windows
    #cv2.imshow("Image", gray_image)
    #cv2.waitKey(0)
    #cv2.imshow("Contrast Enhanced", contrast_image)
    #cv2.imshow("Denoised", denoised_image)
    #cv2.imshow("Sharpened", sharpened_image)
    #cv2.imshow("Erosion", erosion)
    #cv2.imshow("Blur", blurred)
    cv2.waitKey(0)
    #cv2.imshow("Opening", opening)
    #cv2.imshow("Labelled Cells", resized_image)
    img = cv2.imread('Labelled Cells', resized_image)
    cv2_imshow(img)
    cv2.waitKey(0)
    cv2.destroyAllWindows()
    return cell_count

"""One Picture"""

print('Control')
print(count_cells(r"C:\Users\vanes\OneDrive\Desktop\Image J photos\test 6862.jpeg"))

"""Multiple Pictures"""

def avglistfunc(series):
  count = 0
  meanlist= []
  avglist = []
  for val in series:
    meanlist.append(val)
    count += 1
    if count == 3:
      avg = round(np.mean(meanlist),0)
      avglist.append(avg)
      count = 0
      meanlist= []
    else:
      continue
  return avglist

cell_count_dict = {}
cellist = []
formlist = []
letters = ['a','b']
numbers = ['(1)','(2)','(3)']
for var in range(59,64,1):
  for num in numbers:
      Formula = '_'
      Formula += str(var)
      Formula += str(num)
      cellcount = count_cells(fr"/content/{Formula}.jpg")
      formlist.append(Formula)
      cellist.append(cellcount)
      #avglistfunc(celllist)
      cell_count_dict[Formula] = cellcount
cellavg = avglistfunc(cellist)

import pandas as pd
cellavgdf = pd.DataFrame(cellavg)
cellavgdf.to_csv('avgcellcount.csv')